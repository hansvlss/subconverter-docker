name: build

on:
  workflow_dispatch:
    inputs:
      sc_ver:
        description: "subconverter release tag (e.g. v0.9.0)"
        required: false
        default: "v0.9.0"
      push_latest:
        description: "Also push :latest tag?"
        type: boolean
        required: false
        default: true
  push:
    branches: [ main, master ]

permissions:
  contents: read
  packages: write

env:
  IMAGE_NAME: ghcr.io/${{ github.repository_owner }}/subconverter
  SC_VER: ${{ inputs.sc_ver || 'v0.9.0' }}
  PLATFORMS: linux/amd64,linux/arm64

jobs:
  docker:
    runs-on: ubuntu-latest

    steps:
      - name: Checkout
        uses: actions/checkout@v4

      - name: Prepare build context (generate Dockerfile & files)
        shell: bash
        run: |
          set -euxo pipefail
          mkdir -p ctx/vendor ctx/rootfs/etc/subconverter

          # --------- entrypoint ----------
          cat > ctx/entrypoint.sh <<'SH'
          #!/usr/bin/env sh
          set -eu
          : "${SC_PORT:=25500}"
          : "${SC_ADDR:=0.0.0.0}"
          : "${SC_ARGS:=}"
          BIN="/opt/subconverter/subconverter"
          if [ ! -x "$BIN" ]; then
            echo "subconverter binary not found at $BIN" >&2
            ls -al /opt/subconverter || true
            exit 1
          fi
          exec "$BIN" -localaddr "${SC_ADDR}:${SC_PORT}" $SC_ARGS
          SH
          chmod +x ctx/entrypoint.sh

          # --------- default config (可选) ----------
          cat > ctx/rootfs/etc/subconverter/pref.ini <<'INI'
          [common]
          api_access = true
          port = 25500
          INI

          # --------- .dockerignore ----------
          cat > ctx/.dockerignore <<'IGNORE'
          .git
          .github
          **/.DS_Store
          IGNORE

          # --------- Dockerfile ----------
          cat > ctx/Dockerfile <<'DOCKER'
          FROM alpine:3.20
          ARG TARGETARCH
          ARG SC_HOME=/opt/subconverter
          RUN set -eux; \
              apk add --no-cache ca-certificates tzdata bash unzip curl libstdc++; \
              adduser -D -h /home/app app; \
              mkdir -p ${SC_HOME}
          # 复制 vendor 包（由 workflow 准备）
          COPY vendor/ /tmp/vendor/
          # 解包（支持 .tar.gz 与 .zip）
          RUN set -eux; \
              case "${TARGETARCH}" in \
                amd64)  ARCH=linux64 ;; \
                arm64)  ARCH=linuxarm64 ;; \
                *) echo "Unsupported TARGETARCH: ${TARGETARCH}"; exit 1 ;; \
              esac; \
              PKG="/tmp/vendor/subconverter_${ARCH}.tar.gz"; \
              [ -f "$PKG" ] || PKG="/tmp/vendor/subconverter_${ARCH}.zip"; \
              [ -f "$PKG" ] || (echo "vendor package missing"; ls -al /tmp/vendor; exit 2); \
              echo ">>> using package: $PKG"; file "$PKG" || true; \
              case "$PKG" in \
                *.zip)    unzip -q "$PKG" -d "${SC_HOME}" ;; \
                *.tar.gz) tar -xzf "$PKG" -C  "${SC_HOME}" ;; \
                *) echo "Unknown package type: $PKG"; exit 3 ;; \
              esac; \
              # 某些发行包会多一层目录，扁平化
              if [ -d "${SC_HOME}/subconverter" ]; then \
                mv "${SC_HOME}/subconverter/"* "${SC_HOME}/" && rmdir "${SC_HOME}/subconverter"; \
              fi; \
              [ -x "${SC_HOME}/subconverter" ] || (echo "binary not found"; ls -al "${SC_HOME}"; exit 4); \
              chown -R app:app "${SC_HOME}"
          COPY entrypoint.sh /entrypoint.sh
          COPY rootfs/ /
          EXPOSE 25500
          USER app
          ENV SC_PORT=25500 SC_ADDR=0.0.0.0
          ENTRYPOINT ["/entrypoint.sh"]
          DOCKER

      - name: Prepare vendor (download release assets)
        shell: bash
        run: |
          set -euxo pipefail
          cd ctx
          mkdir -p vendor

          # 版本号规范化：无论你填 0.9.0 或 v0.9.0，最终都用 v0.9.0
          IN_VER="${SC_VER:-v0.9.0}"
          N="${IN_VER#v}"; SCV="v${N}"
          echo ">>> SC_VER input=${IN_VER}, normalized=${SCV}"

          # 可能存在的文件名：tar.gz 或 zip（不同版本发布包不一致）
          names_for_arch() {
            case "$1" in
              linux64)     echo "subconverter_linux64.tar.gz subconverter_linux64.zip" ;;
              linuxarm64)  echo "subconverter_linuxarm64.tar.gz subconverter_linuxarm64.zip" ;;
              *)           echo "unknown-arch"; return 1 ;;
            esac
          }

          # 多个上游源，按顺序尝试
          make_urls() {
            local ver="$1" name="$2"
            cat <<EOF
https://github.com/tindy2013/subconverter/releases/download/${ver}/${name}
https://download.fastgit.org/tindy2013/subconverter/releases/download/${ver}/${name}
https://downloads.sourceforge.net/project/subconverter/${ver}/${name}
https://cdn.jsdelivr.net/gh/tindy2013/subconverter@${ver}/${name}
EOF
          }

          # 统一的 curl 选项
          CURL_OPTS=( -fsSL --retry 5 --retry-all-errors --connect-timeout 10 --max-time 120 )

          for ARCH in linux64 linuxarm64; do
            echo "=== downloading for ARCH=${ARCH}"
            OUT_FINAL=""
            for NAME in $(names_for_arch "${ARCH}"); do
              for URL in $(make_urls "${SCV}" "${NAME}"); do
                TMP="vendor/.part_${ARCH}"
                echo ">>> try: ${URL}"
                # 先探测头，便于定位 404/403
                (curl -I "${URL}" || true) | sed 's/^/HEAD: /' || true
                if curl "${CURL_OPTS[@]}" -o "${TMP}" "${URL}"; then
                  # 验证文件类型
                  FT=$(file -b --mime-type "${TMP}" || true)
                  echo ">>> got mime: ${FT}"
                  case "${FT}" in
                    application/gzip|application/x-gzip|application/zip)
                      # 取扩展名
                      case "${NAME}" in
                        *.tar.gz) EXT=".tar.gz" ;;
                        *.zip)    EXT=".zip" ;;
                        *) EXT="" ;;
                      esac
                      OUT_FINAL="vendor/subconverter_${ARCH}${EXT}"
                      mv -f "${TMP}" "${OUT_FINAL}"
                      echo ">>> saved: ${OUT_FINAL}"
                      file "${OUT_FINAL}" || true
                      break 2
                      ;;
                    *)
                      echo "!!! unexpected file type: ${FT}"
                      head -c 200 "${TMP}" || true
                      rm -f "${TMP}"
                      ;;
                  esac
                fi
              done
            done
            if [ -z "${OUT_FINAL}" ]; then
              echo "!!! all download candidates failed for ${ARCH}"
              exit 10
            fi
          done
            if [ -z "$OUT" ]; then
              echo "!!! all download candidates failed for ${ARCH}"
              exit 10
            fi
            case "$OUT" in
              *.tar.gz) EXT=".tar.gz" ;;
              *.zip)    EXT=".zip" ;;
              *) echo "!!! unknown extension for $OUT"; file "$OUT" || true; exit 11 ;;
            esac
            TARGET="vendor/subconverter_${ARCH}${EXT}"
            if [ "$OUT" != "$TARGET" ]; then mv "$OUT" "$TARGET"; fi
            echo ">>> saved: $TARGET"
            file "$TARGET" || true
          done

      - name: Set up QEMU
        uses: docker/setup-qemu-action@v3

      - name: Set up Buildx
        uses: docker/setup-buildx-action@v3

      - name: Login GHCR
        uses: docker/login-action@v3
        with:
          registry: ghcr.io
          username: ${{ github.repository_owner }}
          password: ${{ secrets.GITHUB_TOKEN }}

      - name: Compute tags
        id: meta
        shell: bash
        run: |
          set -euo pipefail
          VER="${SC_VER#v}"
          echo "ver=${VER}" >> "$GITHUB_OUTPUT"
          TAGS="${IMAGE_NAME}:${VER}"
          if [ "${{ inputs.push_latest || 'true' }}" = "true" ]; then
            TAGS="${TAGS},${IMAGE_NAME}:latest"
          fi
          echo "tags=${TAGS}" >> "$GITHUB_OUTPUT"

      - name: Build & Push (multi-arch)
        uses: docker/build-push-action@v6
        with:
          context: ctx
          file: ctx/Dockerfile
          platforms: ${{ env.PLATFORMS }}
          push: true
          tags: ${{ steps.meta.outputs.tags }}
          build-args: |
            SC_VER=${{ env.SC_VER }}

      - name: Upload debug artifacts on failure
        if: failure()
        uses: actions/upload-artifact@v4
        with:
          name: debug-artifacts
          path: |
            ctx/**
